%% 初始化，关闭所有连接
pnet('closeall');
clc;
clear;
close all;
%% 启动Unity程序，并初始化
% 程序说明：发送命令共5字节
%           Byte1：画面/动作切换
%           Byte2：控制画面是否运动
%           Byte3：画面文字显示（离线训练实验无文字提示）
%           Byte4：动作类型
%           Byte5：预留
%system('F:\CASIA\mwl_data_collection\climbstair\ClimbStair3.exe&');       % Unity动画exe文件地址
%system('E:\MI_engagement\unity_test\unity_test\build_test\unity_test.exe&');
system('E:\MI_UpperLimb_AO\UpperLimb_AO\UpperLimb_AO\build_test\unity_test.exe&');
pause(3)
UnityControl = tcpip('localhost', 8881, 'NetworkRole', 'client');          % 新的端口改为8881
fopen(UnityControl);
pause(1)
sendbuf = uint8(1:5);
sendbuf(1,1) = hex2dec('00') ;
sendbuf(1,2) = hex2dec('00') ;
sendbuf(1,3) = hex2dec('00') ;
sendbuf(1,4) = hex2dec('00') ;
sendbuf(1,5) = hex2dec('00') ;
fwrite(UnityControl,sendbuf);
pause(3)

%% 设置脑电采集参数
init = 0;
freq = 256;
startStop = 1;
con = pnet('tcpconnect','127.0.0.1',4455);                                 % 建立一个连接
status = CheckNetStreamingVersion(con);                                    % 判断版本信息，正确返回状态值为1
[~, basicInfo] = ClientGetBasicMessage(con);                               % 获取设备基本信息basicInfo包含 size,eegChan,sampleRate,dataSize
[~, infoList] = ClientGetChannelMessage(con,basicInfo.eegChan);            % 获取通道信息
%% 在线实验参数设置部分，用于设置每一个被试的情况，依据被试情况进行修改

% 运动想象基本参数设置
subject_name = 'Jyt_test';  % 被试姓名
sub_offline_collection_folder = 'Jyt_test_data';  % 被试的离线采集数据
session_idx = 1;  % session index数量，如果是1的话，会自动生成相关排布
MotorClass = 2; % 运动想象动作数量，注意这里是纯设计的运动想象动作的数量，不包括空想idle状态
DiffLevels = [1,2];  % 对于上面的运动想象的难度排布，越靠后越难，其中的1,2对应的是运动想象的类型，和unity对应
MajorPoportion = 0.6;  % 每一个session里面不同类型运动想象总数所占的比值
TrialNum = 40;  % 每一个session里面的trial的数量

% 运动想象任务调整设置
score_init = 1.0;  % 这是在之前离线时候计算的mu衰减和EI指标的均值
MaxMITime = 30; % 在线运动想象最大允许时间 
sample_frequency = 256; 
WindowLength = 512;  % 每个窗口的长度
channels = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32];  % 选择的通道
mu_channels = struct('C3',1, 'C4',2);  % 用于计算ERD/ERS的几个channels，是C3和C4两个通道,需要设定位置
EI_channels = struct('Fp1', 1, 'Fp2', 2, 'F7', 3, 'F3', 4, 'Fz', 5, 'F4', 6, 'F8', 7);  % 用于计算EI指标的几个channels，需要确定下位置的
weight_mu = 0.6;  % 用于计算ERD/ERS指标和EI指标的加权和
MI_MUSup_thre = 0;  % 用于MI时候的阈值初始化
MI_MUSup_thre_weight_baseline = 0.8;  % 用于计算MI时候的mu衰减的阈值权重初始化数值，这个权重一般是和分类的概率相关的，也会随着相关数据进行调整
MI_MUSup_thre_weight = MI_MUSup_thre_weight_baseline;  % 用于计算MI时候的mu衰减的阈值权重数值，这个权重一般是和分类的概率相关的，也会随着相关数据进行调整

% 通信设置
ip = '172.18.22.21';
port = 8888;  % 和后端服务器连接的两个参数

%% 准备初始的存储数据的文件夹
foldername = ['.\\', FunctionNowFilename([subject_name, '_'], '_data')]; % 指定文件夹路径和名称
if ~exist(foldername, 'dir')
   mkdir(foldername);
end

%% 生成mu衰减的追踪轨迹
% 读取之前的离线采集的数据
foldername_Scores = [foldername, '\\Offline_EEGMI_Scores_', subject_name]; % 指定之前存储的离线文件夹路径和名称
mean_std_EI = load([foldername_Scores, '\\', ['Offline_EEGMI_Scores_', subject_name], '.mat' ], 'mean_std_EI');
mean_std_muSup = load([foldername_Scores, '\\', ['Offline_EEGMI_Scores_', subject_name], '.mat' ], 'mean_std_muSup');

% 生成现在的轨迹
traj = generate_traj(mean_std_muSup, TrialNum);

%% 运动想象内容安排
TrialIndex = randperm(TrialNum);                                           % 根据采集的数量生成随机顺序的数组
%All_data = [];
Trigger = 0;                                                               % 初始化Trigger，用于后续的数据存储
AllTrial = 0;

randomindex = [];                                                          % 初始化trials的集合
for i= 1:(MotorClasses)                                                    % 注意，这里只生成运动想象的任务，后面会依据实际情况加入相关的静息状态
    index_i = ones(TrialNum/MotorClasses,1)*i;                             % size TrialNum/MotorClasses*1，各种任务
    randomindex = [randomindex; index_i];                                  % 各个任务整合，最终size TrialNum*1
end

RandomTrial = randomindex(TrialIndex);                                     % 随机生成各个Trial对应的任务

%% 开始实验，离线采集
Timer = 0;
TrialData = [];
scores = [];  % 用于存储每一个trial里面的每一个window的分数值
EI_indices = [];  % 用于存储每一个trial里面的每一个window的EI分数值
mu_powers = [];  % 用于存储每一个trial里面的每一个window的mu频带的能量数值
scores_trial = [];  % 用于存储每一个trial的平均分数值
mu_suppressions = [];  % 用于存储mu_suppression
clsFlag = 0; % 用于判断实时分类是否正确的flag
clsTime = 100;  % 初始化分类正确的时间
RestTimeLenBaseline = 3 + session_idx;  % 休息时间随着session的数量增加
RestTimeLen = RestTimeLenBaseline;  % 初始化休息时间
Trials = RandomTrial;

while(AllTrial <= TrialNum)
    %% 提示专注阶段
    if Timer==0  %提示专注 cross
        Trigger = 6;
        sendbuf(1,1) = hex2dec('01') ;
        sendbuf(1,2) = hex2dec('00') ;
        sendbuf(1,3) = hex2dec('00') ;
        sendbuf(1,4) = hex2dec('00') ;
        fwrite(UnityControl,sendbuf);       
        AllTrial = AllTrial + 1;
    end
    
    %% 运动想象阶段
    if Timer==2
        if Trials(AllTrial)==0  % 空想任务
            Trigger = 1;
            sendbuf(1,1) = hex2dec('03') ;
            sendbuf(1,2) = hex2dec('00') ;
            sendbuf(1,3) = hex2dec('00') ;
            sendbuf(1,4) = hex2dec('00') ;
            fwrite(UnityControl,sendbuf);  
        end
        if Trials(AllTrial)> 0  % 运动想象任务
            Trigger = Trials(AllTrial);  % 播放动作的AO动画（Idle, MI1, MI2）
            mat2unity = ['0', num2str(Trigger + 3)];
            sendbuf(1,1) = hex2dec(mat2unity) ;
            sendbuf(1,2) = hex2dec('00') ;
            sendbuf(1,3) = hex2dec('00') ;
            sendbuf(1,4) = hex2dec('00') ;
            fwrite(UnityControl,sendbuf);  
        end
        % 第2s的时候，取512的Trigger==6的窗口，数据处理并且进行分析
        rawdata = TrialData(:,end-512+1:end);  % 取前一个512的窗口
        rawdata = rawdata(2:end,:);
        % 这里仅仅提取在MI之前的频带能量
        [~, ~, mu_power_] = Online_DataPreprocess(rawdata, 6, sample_frequency, WindowLength, channels);
        mu_power_ = [mu_power_; Trigger];
        mu_powers = [mu_powers, mu_power_];  % 添加相关的mu节律能量

        % 确定这一轮的阈值
        Trigger_num_ = count_trigger(Trials, Trigger);
        MI_MUSup_thre = traj{Trigger_num_}(Trigger_num_);  % 计算阈值
        % 确定加权之后的阈值
        MI_MUSup_thre = MI_MUSup_thre_weight * MI_MUSup_thre;
        % threshold 数据传输设置以及显示
       sendbuf(1,6) = uint8((MI_MUSup_thre));
       fwrite(UnityControl,sendbuf);  
    end
    
    % 第4s开始取512的Trigger~=6的MI的窗口，数据处理并且进行分析
    if Timer > 3 && Trials(AllTrial)> 0 && clsFlag == 0
        rawdata = TrialData(:,end-512+1:end);  % 取前一个512的窗口
        rawdata = rawdata(2:end,:);
        
        [FilteredDataMI, EI_index, mu_power_MI] = Online_DataPreprocess(rawdata, Trials(AllTrial), sample_frequency, WindowLength, channels);
        % 计算两个指标
        mu_suppression = MI_MuSuperesion(mu_power_, mu_power_MI, mu_channels);  
        EI_index_score = EI_index_Caculation(EI_index, EI_channels);
        
        score = weight_mu * mu_suppression + (1 - weight_mu) * EI_index_score;  % 计算得分
        scores = [scores, score];  % 保存得分

        % 发送得分以及一系列数据
        config_data = [WindowLength;size(channels, 2);Trials(AllTrial);session_idx;AllTrial;size(scores, 2);score(1,1);0;0;0;0 ];
        order = 1.0;
        resultMI = Online_Data2Server_Communicate(order, FilteredDataMI, ip, port, subject_name, config_data, foldername);  % 传输数据给线上的模型，看分类情况
        
        % 得分数据实时显示
        visual_feedback = (resultMI * mu_suppression)/MI_MUSup_thre;
        sendbuf(1,5) = uint8((visual_feedback*100.0));
        fwrite(UnityControl,sendbuf);
           
        % 判断是否达成要求
        if resultMI * mu_suppression > MI_MUSup_thre
            clsFlag = 1;  % 识别正确，置1
        else
            clsFlag = 0;
        end

%         if resultMI == Trials(AllTrial)
%             clsFlag = 1;  % 识别正确，置1
%         else
%             clsFlag = 0;
%         end   

        % 存储这一系列指标的数值
        EI_index = [EI_index; Trigger];
        mu_power_MI = [mu_power_MI; Trigger];  % 这里添加上Trigger的相关数值，方便存储
        mu_suppression = [mu_suppression; Trigger]; % 这里添加上Trigger的相关数值，方便存储

        EI_indices = [EI_indices, EI_index];  % 添加相关的EI指标数值  
        mu_powers = [mu_powers, mu_power_MI];  % 添加相关的mu节律能量
        mu_suppressions = [mu_suppressions, mu_suppression];  % 添加相关的mu衰减情况，用于后续的分析
    end
    
   %% 运动想象给与反馈阶段（想对/时间范围内没有想对）,同时更新模型
   % 想对了开始播放动作 
   if clsFlag == 1 
        clsTime = Timer;  % 这是分类正确的时间
        if Trials(AllTrial) > 0  % 运动想象任务
            Trigger = Trials(AllTrial);  % 播放动作的AO动画（Idle, MI1, MI2）
            mat2unity = ['0', num2str(Trigger + 3)];
            sendbuf(1,1) = hex2dec(mat2unity);
            sendbuf(1,2) = hex2dec('01') ;
            sendbuf(1,3) = hex2dec('01') ;  % 给与反馈，显示文字
            sendbuf(1,4) = hex2dec('00') ;
            fwrite(UnityControl,sendbuf);  
        end
        % 传输数据和更新模型
        config_data = [WindowLength;size(channels, 2);Trials(AllTrial);session_idx;AllTrial;size(scores, 2);score;0;0;0;0 ];
        order = 2.0;  % 传输数据和训练的命令
        Online_Data2Server_Send(order, [0,0,0,0], ip, port, subject_name, config_data);  % 发送指令，让服务器更新数据，[0,0,0,0]单纯是用于凑下数据，防止应为空集影响传输
   end
    
    % 想错了开始休息和提醒
    if clsFlag == 0 && Timer == (MaxMITime)
        if Trials(AllTrial) > 0  % 运动想象任务
            Trigger = Trials(AllTrial);  % 播放动作的AO动画（Idle, MI1, MI2）
            mat2unity = ['0', num2str(Trigger + 3)];
            sendbuf(1,1) = hex2dec(mat2unity);
            sendbuf(1,2) = hex2dec('00') ;
            sendbuf(1,3) = hex2dec('02') ;  % 给与反馈，显示文字
            sendbuf(1,4) = hex2dec('00') ;
            fwrite(UnityControl,sendbuf);  
        end
        % 传输数据和更新模型
        config_data = [WindowLength;size(channels, 2);Trials(AllTrial);session_idx;AllTrial;size(scores, 2);score(1,1);0;0;0;0 ];
        order = 2.0;  % 传输数据和训练的命令
        Online_Data2Server_Send(order, [0,0,0,0], ip, port, subject_name, config_data);  % 发送指令，让服务器更新数据，[0,0,0,0]单纯是用于凑下数据，防止应为空集影响传输
    end
    
   %% 休息阶段，确定下一个动作
    % 空想只给5s就休息
    if Timer==7 && Trials(AllTrial)==0  %开始休息
        Trigger = 7;
        sendbuf(1,1) = hex2dec('02') ;
        sendbuf(1,2) = hex2dec('00') ;
        sendbuf(1,3) = hex2dec('00') ;
        sendbuf(1,4) = hex2dec('00') ;
        fwrite(UnityControl,sendbuf);  
        % 更新算法
        config_data = [WindowLength;size(channels, 2);Trials(AllTrial);session_idx;AllTrial;size(scores, 2);score(1,1);0;0;0;0 ];
        order = 2.0;  % 传输数据和训练的命令
        Online_Data2Server_Send(order, [0,0,0,0], ip, port, subject_name, config_data);  % 发送指令，让服务器更新数据，[0,0,0,0]单纯是用于凑下数据，防止应为空集影响传输
        % 进入确定下一个任务
        average_score = average(EI_indices(1, :));  % 这里换成EI指标，后续可能还会换
        scores_trial = [scores_trial, average_score];  % 存储好平均的分数
        [Trials, MI_MUSup_thre_weight, RestTimeLen] = TaskAdjustUpgraded(scores_trial, Trials, AllTrial, MI_MUSup_thre_weight_baseline, RestTimeLenBaseline);
    end
    
    % 运动想象想对了之后，AO结束了之后让人休息
    if Timer == (clsTime + 5) && clsFlag == 1  %开始休息
        Trigger = 7;
        sendbuf(1,1) = hex2dec('02') ;
        sendbuf(1,2) = hex2dec('00') ;
        sendbuf(1,3) = hex2dec('00') ;
        sendbuf(1,4) = hex2dec('00') ;
        fwrite(UnityControl,sendbuf);  
        % 进入确定下一个任务
        average_score = average(EI_indices(1, :));  % 这里换成EI指标，后续可能还会换
        scores_trial = [scores_trial, average_score];  % 存储好平均的分数
        [Trials, MI_MUSup_thre_weight, RestTimeLen] = TaskAdjustUpgraded(scores_trial, Trials, AllTrial, MI_MUSup_thre_weight_baseline, RestTimeLenBaseline);
    end
    
    % 运动想象没有想对，提醒结束了之后让人休息
    if clsFlag == 0 && Timer == (MaxMITime + 3)
        Trigger = 7;
        sendbuf(1,1) = hex2dec('02') ;
        sendbuf(1,2) = hex2dec('00') ;
        sendbuf(1,3) = hex2dec('00') ;
        sendbuf(1,4) = hex2dec('00') ;
        fwrite(UnityControl,sendbuf);  
        % 进入确定下一个任务
        average_score = average(EI_indices(1, :));  % 这里换成EI指标，后续可能还会换
        scores_trial = [scores_trial, average_score];  % 存储好平均的分数
        [Trials, MI_MUSup_thre_weight, RestTimeLen] = TaskAdjustUpgraded(scores_trial, Trials, AllTrial, MI_MUSup_thre_weight_baseline, RestTimeLenBaseline);
    end
    
    %% 时钟更新
    % 生成标签
    TriggerRepeat = repmat(Trigger,1,256);  % 生成标签
    % 脑电信号采集
    tic
    pause(1);
    [~, data] = ClientGetDataPacket(con,basicInfo,infoList,startStop,init); % Obtain EEG data, 需要在ClientGetDataPacket设置要不要移除基线
    toc
    data = [data;TriggerRepeat];
    TrialData = [TrialData,data];
    Timer = Timer + 1;
    
    %% 最后的各个数值复位
    % 空想任务想象5s，到第7s之后开始休息，到第10s就结束任务
    if Timer == 10 && Trials(AllTrial)==0  %结束休息，准备下一个
        % 存储相关的EI指标和mu节律能量的数据
        SaveMIEngageTrials(EI_indices, mu_powers, mu_suppressions, subject_name, foldername, config_data);
        %计时器清0
        Timer = 0;  % 计时器清0
        % 每一个trial的数值还原
        scores = [];  % 分数值还原
        EI_indices = [];  % EI分数值还原
        mu_powers = [];  % mu频带的能量数值还原
        RestTimeLen = 3;  % 休息时间还原
        disp(['Trial: ', num2str(AllTrial), ', Task: ', num2str(Trials(AllTrial))]);  % 显示相关数据
    end
    % 想对了之后，AO之后，休息3s之后，结束休息，准备下一个
    if Timer == (clsTime + 5 + RestTimeLen) && clsFlag == 1  %结束休息
        % 存储相关的EI指标和mu节律能量的数据
        SaveMIEngageTrials(EI_indices, mu_powers, mu_suppressions, subject_name, foldername, config_data);
        % 计时器清0
        Timer = 0;  % 计时器清0
        % clsflag清0
        clsFlag = 0;  % 分类flag清0
        % 每一个trial的数值还原
        scores = [];  % 分数值还原
        EI_indices = [];  % EI分数值还原
        mu_powers = [];  % mu频带的能量数值还原
        % 其余设置还原
        RestTimeLen = 3;  % 休息时间还原
        disp(['Trial: ', num2str(AllTrial), ', Task: ', num2str(Trials(AllTrial))]);  % 显示相关数据
    end
    % 运动想象没有想对，提醒之后，休息3s之后，结束休息，准备下一个
    if clsFlag == 0 && Timer == (MaxMITime + 3 + RestTimeLen)
        % 存储相关的EI指标和mu节律能量的数据
        SaveMIEngageTrials(EI_indices, mu_powers, mu_suppressions, subject_name, foldername, config_data);
        % 计时器清0
        Timer = 0;  % 计时器清0
        % clsflag清0
        clsFlag = 0;  % 分类flag清0
        % 每一个trial的数值还原
        scores = [];  % 分数值还原
        EI_indices = [];  % EI分数值还原
        mu_powers = [];  % mu频带的能量数值还原
        % 其余设置还原
        RestTimeLen = 3;  % 休息时间还原
        disp(['Trial: ', num2str(AllTrial), ', Task: ', num2str(Trials(AllTrial))]);  % 显示相关数据
    end
end
%% 存储原始数据
close all
TrialData = TrialData(2:end,:);  %去掉矩阵第一行
ChanLabel = flip({infoList.chanLabel});
pnet('closeall')   % 将连接关闭
% 存储原始数据
foldername_rawdata = [foldername, '\\Online_EEGMI_RawData_', subject_name]; % 指定文件夹路径和名称
if ~exist(foldername_rawdata, 'dir')
   mkdir(foldername_rawdata);
end
save([foldername_rawdata, '\\', FunctionNowFilename(['Online_EEGMI_RawData_',str(session_idx), '_', subject_name], '.mat' )],'TrialData','Trials','ChanLabel');

%% 存储在运动想象过程中的参与度指标
function SaveMIEngageTrials(EI_indices, mu_powers, mu_suppressions, subject_name, foldername, config_data)
    
    foldername = [foldername, '\\Offline_Engagements_', subject_name]; % 检验文件夹是否存在
    if ~exist(foldername, 'dir')
       mkdir(foldername);
    end

    save([foldername, '\\', FunctionNowFilename(['Online_EEG_data2Server_', subject_name, '_class_', num2str(config_data(3,1)),  ...
        '_session_', num2str(config_data(4,1)), '_trial_', num2str(config_data(5,1)), ...
        '_window_', num2str(config_data(6,1)), 'EI_mu' ], '.mat' )],'EI_indices',' mu_powers','mu_suppressions');  % 存储相关的数值
end
%% 计算相关mu频带衰减指标
function mu_suppresion = MI_MuSuperesion(mu_power_, mu_power, mu_channels)
    ERD_C3 = (mu_power(mu_channels.C3, 1) - mu_power_(mu_channels.C3, 1))/mu_power_(mu_channels.C3, 1); 
    ERD_C4 = (mu_power(mu_channels.C4, 1) - mu_power_(mu_channels.C4, 1))/mu_power_(mu_channels.C4, 1);  % 计算两个脑电位置的相关的指标 
    mu_suppresion = abs(ERD_C4 - ERD_C3);
end

%% 计算相关的EI指标的函数
function EI_index_score = EI_index_Caculation(EI_index, EI_channels)
    channels_ = [EI_channels.Fp1,EI_channels.Fp2, EI_channels.F7, EI_channels.F3, EI_channels.Fz, EI_channels.F4, EI_channels.F8'];
    EI_index_score = mean(EI_index(channels_, 1));
end

%% 生成轨迹的函数
function traj = generate_traj(mean_std_muSup, TrialNum)
    % 获取类别的数量
    n = size(mean_std_muSup, 2);

    % 初始化一个空的 cell 数组来存储每个类别的轨迹
    traj = cell(1, n);

    % 对于每一个类别
    for i = 1:n
        % 提取 mean 和 std
        mean_val = mean_std_muSup(1, i);
        std_val = mean_std_muSup(2, i);

        % 初始化一个空的数组来存储轨迹
        traj{i} = zeros(TrialNum, 1);

        % 计算轨迹
        for x = 1:TrialNum
            traj{i}(x) = mean_val + (std_val) * (1 - exp(-0.95 * x / TrialNum));
        end
    end
end
% Trials里面判断当前类别已经出现过多少次的函数，用于精细的轨迹生成
function count = count_trigger(Trials, AllTrial)
    % 提取 Trigger
    Trigger = Trials(AllTrial);
    
    % 计算 Trigger 在 Trials(1:AllTrial-1) 中的数量
    count = sum(Trials(1:AllTrial-1) == Trigger);
end
